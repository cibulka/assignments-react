import { PlusIcon } from "@radix-ui/react-icons";
import React, { useCallback, useState } from "react";
import styled from "styled-components";
import { Form } from "./form";
import { API, BE_URL } from "../constants/server";
import { ItemsActionType } from "./providers/items-provider/action-types";
import { useItemsProvider } from "./providers/items-provider/hooks";
import { Item } from "../types/server";

const StyledDiv = styled.header`
    display: flex;
    justify-content: space-between;

    button {
        all: unset;

        width: 25px;
        height: 25px;

        background-color: ${(props) => props.theme.colors.grass9};
        border: 1px solid;
        border-color: ${(props) => props.theme.colors.olive9};
        border-radius: 50%;

        color: #fff;
    }
`;

type HeaderProps = {
    children: React.ReactNode;
    onItemAdd: (label: string) => void;
};

export const Header = ({ children, onItemAdd }: HeaderProps) => {
    const [isForm, setIsForm] = useState(false);

    const { dispatch } = useItemsProvider();

    const onOpenForm = useCallback(() => setIsForm(true), []);
    const onCloseForm = useCallback(() => setIsForm(false), []);

    /**
     * This is not an ideal solution - `props.onItemAdd` should be made async, 
     * so we can work either with:
     * - unresolved state (to show the spinner)
     * - error response
     * - successful response (to work with values generated by BE - ID, createdAt)
     * The task is "not change the API", so I'm rather using "the optimistic approach" to adding 
     * the new items directly to the state. This is not ideal, as there will be 
     * a mismatch between BE values and FE-generated values.
     * 
     * Another approach (without changing the API) would be to force re-fefetch new values on FE,
     * after some short timeout for example. This feel even dirtier - there is no guarantee how much
     * time will BE need for saving the values.
     */
    const onSubmit = useCallback((label: string) => {
        const now = Date.now();
        const payload: Item = {
            label,
            createdAt: now,
            isDone: false,
            id: now,
        };

        dispatch?.({ type: ItemsActionType.ADD_TODO, payload });
        onItemAdd(label);
    }, [onCloseForm]);

    return (
        <StyledDiv>
            <h1>{children}</h1>
            {isForm ? (
                <Form initialValue="" onCancel={onCloseForm} onSubmit={onSubmit} /> 
            ) : (
                <button type="button" onClick={onOpenForm}>
                    <PlusIcon />
                </button>
            )}
        </StyledDiv>
    );
};
